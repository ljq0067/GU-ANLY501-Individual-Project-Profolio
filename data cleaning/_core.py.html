<html>
<head>
<title>_core.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #000080; font-weight: bold;}
.s1 { color: #000000;}
.s2 { color: #808080; font-style: italic;}
.s3 { color: #008000; font-weight: bold;}
.s4 { color: #0000ff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_core.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span>warnings
<span class="s0">import </span>itertools
<span class="s0">from </span>copy <span class="s0">import </span>copy
<span class="s0">from </span>functools <span class="s0">import </span>partial
<span class="s0">from </span>collections.abc <span class="s0">import </span>Iterable, Sequence, Mapping
<span class="s0">from </span>numbers <span class="s0">import </span>Number
<span class="s0">from </span>datetime <span class="s0">import </span>datetime
<span class="s0">from </span>distutils.version <span class="s0">import </span>LooseVersion

<span class="s0">import </span>numpy <span class="s0">as </span>np
<span class="s0">import </span>pandas <span class="s0">as </span>pd
<span class="s0">import </span>matplotlib <span class="s0">as </span>mpl

<span class="s0">from </span>._decorators <span class="s0">import </span>(
    share_init_params_with_map,
)
<span class="s0">from </span>.palettes <span class="s0">import </span>(
    QUAL_PALETTES,
    color_palette,
)
<span class="s0">from </span>.utils <span class="s0">import </span>(
    get_color_cycle,
    remove_na,
)


<span class="s0">class </span>SemanticMapping:
    <span class="s2">&quot;&quot;&quot;Base class for mapping data values to plot attributes.&quot;&quot;&quot;</span>

    <span class="s2"># -- Default attributes that all SemanticMapping subclasses must set</span>

    <span class="s2"># Whether the mapping is numeric, categorical, or datetime</span>
    map_type = <span class="s0">None</span>

    <span class="s2"># Ordered list of unique values in the input data</span>
    levels = <span class="s0">None</span>

    <span class="s2"># A mapping from the data values to corresponding plot attributes</span>
    lookup_table = <span class="s0">None</span>

    <span class="s0">def </span>__init__(self, plotter):

        <span class="s2"># TODO Putting this here so we can continue to use a lot of the</span>
        <span class="s2"># logic that's built into the library, but the idea of this class</span>
        <span class="s2"># is to move towards semantic mappings that are agnositic about the</span>
        <span class="s2"># kind of plot they're going to be used to draw.</span>
        <span class="s2"># Fully achieving that is going to take some thinking.</span>
        self.plotter = plotter

    <span class="s0">def </span>map(cls, plotter, *args, **kwargs):
        <span class="s2"># This method is assigned the __init__ docstring</span>
        method_name = <span class="s3">&quot;_{}_map&quot;</span>.format(cls.__name__[:-<span class="s4">7</span>].lower())
        setattr(plotter, method_name, cls(plotter, *args, **kwargs))
        <span class="s0">return </span>plotter

    <span class="s0">def </span>_lookup_single(self, key):
        <span class="s2">&quot;&quot;&quot;Apply the mapping to a single data value.&quot;&quot;&quot;</span>
        <span class="s0">return </span>self.lookup_table[key]

    <span class="s0">def </span>__call__(self, key, *args, **kwargs):
        <span class="s2">&quot;&quot;&quot;Get the attribute(s) values for the data key.&quot;&quot;&quot;</span>
        <span class="s0">if </span>isinstance(key, (list, np.ndarray, pd.Series)):
            <span class="s0">return </span>[self._lookup_single(k, *args, **kwargs) <span class="s0">for </span>k <span class="s0">in </span>key]
        <span class="s0">else</span>:
            <span class="s0">return </span>self._lookup_single(key, *args, **kwargs)


@share_init_params_with_map
<span class="s0">class </span>HueMapping(SemanticMapping):
    <span class="s2">&quot;&quot;&quot;Mapping that sets artist colors according to data values.&quot;&quot;&quot;</span>
    <span class="s2"># A specification of the colors that should appear in the plot</span>
    palette = <span class="s0">None</span>

    <span class="s2"># An object that normalizes data values to [0, 1] range for color mapping</span>
    norm = <span class="s0">None</span>

    <span class="s2"># A continuous colormap object for interpolating in a numeric context</span>
    cmap = <span class="s0">None</span>

    <span class="s0">def </span>__init__(
        self, plotter, palette=<span class="s0">None</span>, order=<span class="s0">None</span>, norm=<span class="s0">None</span>,
    ):
        <span class="s2">&quot;&quot;&quot;Map the levels of the `hue` variable to distinct colors. 
 
        Parameters 
        ---------- 
        # TODO add generic parameters 
 
        &quot;&quot;&quot;</span>
        super().__init__(plotter)

        data = plotter.plot_data.get(<span class="s3">&quot;hue&quot;</span>, pd.Series(dtype=float))

        <span class="s0">if </span>data.notna().any():

            map_type = self.infer_map_type(
                palette, norm, plotter.input_format, plotter.var_types[<span class="s3">&quot;hue&quot;</span>]
            )

            <span class="s2"># Our goal is to end up with a dictionary mapping every unique</span>
            <span class="s2"># value in `data` to a color. We will also keep track of the</span>
            <span class="s2"># metadata about this mapping we will need for, e.g., a legend</span>

            <span class="s2"># --- Option 1: numeric mapping with a matplotlib colormap</span>

            <span class="s0">if </span>map_type == <span class="s3">&quot;numeric&quot;</span>:

                data = pd.to_numeric(data)
                levels, lookup_table, norm, cmap = self.numeric_mapping(
                    data, palette, norm,
                )

            <span class="s2"># --- Option 2: categorical mapping using seaborn palette</span>

            <span class="s0">elif </span>map_type == <span class="s3">&quot;categorical&quot;</span>:

                cmap = norm = <span class="s0">None</span>
                levels, lookup_table = self.categorical_mapping(
                    data, palette, order,
                )

            <span class="s2"># --- Option 3: datetime mapping</span>

            <span class="s0">else</span>:
                <span class="s2"># TODO this needs actual implementation</span>
                cmap = norm = <span class="s0">None</span>
                levels, lookup_table = self.categorical_mapping(
                    <span class="s2"># Casting data to list to handle differences in the way</span>
                    <span class="s2"># pandas and numpy represent datetime64 data</span>
                    list(data), palette, order,
                )

            self.map_type = map_type
            self.lookup_table = lookup_table
            self.palette = palette
            self.levels = levels
            self.norm = norm
            self.cmap = cmap

    <span class="s0">def </span>_lookup_single(self, key):
        <span class="s2">&quot;&quot;&quot;Get the color for a single value, using colormap to interpolate.&quot;&quot;&quot;</span>
        <span class="s0">try</span>:
            <span class="s2"># Use a value that's in the original data vector</span>
            value = self.lookup_table[key]
        <span class="s0">except </span>KeyError:
            <span class="s2"># Use the colormap to interpolate between existing datapoints</span>
            <span class="s2"># (e.g. in the context of making a continuous legend)</span>
            <span class="s0">try</span>:
                normed = self.norm(key)
            <span class="s0">except </span>TypeError <span class="s0">as </span>err:
                <span class="s0">if </span>np.isnan(key):
                    value = (<span class="s4">0</span>, <span class="s4">0</span>, <span class="s4">0</span>, <span class="s4">0</span>)
                <span class="s0">else</span>:
                    <span class="s0">raise </span>err
            <span class="s0">else</span>:
                <span class="s0">if </span>np.ma.is_masked(normed):
                    normed = np.nan
                value = self.cmap(normed)
        <span class="s0">return </span>value

    <span class="s0">def </span>infer_map_type(self, palette, norm, input_format, var_type):
        <span class="s2">&quot;&quot;&quot;Determine how to implement the mapping.&quot;&quot;&quot;</span>
        <span class="s0">if </span>palette <span class="s0">in </span>QUAL_PALETTES:
            map_type = <span class="s3">&quot;categorical&quot;</span>
        <span class="s0">elif </span>norm <span class="s0">is not None</span>:
            map_type = <span class="s3">&quot;numeric&quot;</span>
        <span class="s0">elif </span>isinstance(palette, (dict, list)):
            map_type = <span class="s3">&quot;categorical&quot;</span>
        <span class="s0">elif </span>input_format == <span class="s3">&quot;wide&quot;</span>:
            map_type = <span class="s3">&quot;categorical&quot;</span>
        <span class="s0">else</span>:
            map_type = var_type

        <span class="s0">return </span>map_type

    <span class="s0">def </span>categorical_mapping(self, data, palette, order):
        <span class="s2">&quot;&quot;&quot;Determine colors when the hue mapping is categorical.&quot;&quot;&quot;</span>
        <span class="s2"># -- Identify the order and name of the levels</span>

        levels = categorical_order(data, order)
        n_colors = len(levels)

        <span class="s2"># -- Identify the set of colors to use</span>

        <span class="s0">if </span>isinstance(palette, dict):

            missing = set(levels) - set(palette)
            <span class="s0">if </span>any(missing):
                err = <span class="s3">&quot;The palette dictionary is missing keys: {}&quot;</span>
                <span class="s0">raise </span>ValueError(err.format(missing))

            lookup_table = palette

        <span class="s0">else</span>:

            <span class="s0">if </span>palette <span class="s0">is None</span>:
                <span class="s0">if </span>n_colors &lt;= len(get_color_cycle()):
                    colors = color_palette(<span class="s0">None</span>, n_colors)
                <span class="s0">else</span>:
                    colors = color_palette(<span class="s3">&quot;husl&quot;</span>, n_colors)
            <span class="s0">elif </span>isinstance(palette, list):
                <span class="s0">if </span>len(palette) != n_colors:
                    err = <span class="s3">&quot;The palette list has the wrong number of colors.&quot;</span>
                    <span class="s0">raise </span>ValueError(err)
                colors = palette
            <span class="s0">else</span>:
                colors = color_palette(palette, n_colors)

            lookup_table = dict(zip(levels, colors))

        <span class="s0">return </span>levels, lookup_table

    <span class="s0">def </span>numeric_mapping(self, data, palette, norm):
        <span class="s2">&quot;&quot;&quot;Determine colors when the hue variable is quantitative.&quot;&quot;&quot;</span>
        <span class="s0">if </span>isinstance(palette, dict):

            <span class="s2"># The presence of a norm object overrides a dictionary of hues</span>
            <span class="s2"># in specifying a numeric mapping, so we need to process it here.</span>
            levels = list(sorted(palette))
            colors = [palette[k] <span class="s0">for </span>k <span class="s0">in </span>sorted(palette)]
            cmap = mpl.colors.ListedColormap(colors)
            lookup_table = palette.copy()

        <span class="s0">else</span>:

            <span class="s2"># The levels are the sorted unique values in the data</span>
            levels = list(np.sort(remove_na(data.unique())))

            <span class="s2"># --- Sort out the colormap to use from the palette argument</span>

            <span class="s2"># Default numeric palette is our default cubehelix palette</span>
            <span class="s2"># TODO do we want to do something complicated to ensure contrast?</span>
            palette = <span class="s3">&quot;ch:&quot; </span><span class="s0">if </span>palette <span class="s0">is None else </span>palette

            <span class="s0">if </span>isinstance(palette, mpl.colors.Colormap):
                cmap = palette
            <span class="s0">else</span>:
                cmap = color_palette(palette, as_cmap=<span class="s0">True</span>)

            <span class="s2"># Now sort out the data normalization</span>
            <span class="s0">if </span>norm <span class="s0">is None</span>:
                norm = mpl.colors.Normalize()
            <span class="s0">elif </span>isinstance(norm, tuple):
                norm = mpl.colors.Normalize(*norm)
            <span class="s0">elif not </span>isinstance(norm, mpl.colors.Normalize):
                err = <span class="s3">&quot;``hue_norm`` must be None, tuple, or Normalize object.&quot;</span>
                <span class="s0">raise </span>ValueError(err)

            <span class="s0">if not </span>norm.scaled():
                norm(np.asarray(data.dropna()))

            lookup_table = dict(zip(levels, cmap(norm(levels))))

        <span class="s0">return </span>levels, lookup_table, norm, cmap


@share_init_params_with_map
<span class="s0">class </span>SizeMapping(SemanticMapping):
    <span class="s2">&quot;&quot;&quot;Mapping that sets artist sizes according to data values.&quot;&quot;&quot;</span>
    <span class="s2"># An object that normalizes data values to [0, 1] range</span>
    norm = <span class="s0">None</span>

    <span class="s0">def </span>__init__(
        self, plotter, sizes=<span class="s0">None</span>, order=<span class="s0">None</span>, norm=<span class="s0">None</span>,
    ):
        <span class="s2">&quot;&quot;&quot;Map the levels of the `size` variable to distinct values. 
 
        Parameters 
        ---------- 
        # TODO add generic parameters 
 
        &quot;&quot;&quot;</span>
        super().__init__(plotter)

        data = plotter.plot_data.get(<span class="s3">&quot;size&quot;</span>, pd.Series(dtype=float))

        <span class="s0">if </span>data.notna().any():

            map_type = self.infer_map_type(
                norm, sizes, plotter.var_types[<span class="s3">&quot;size&quot;</span>]
            )

            <span class="s2"># --- Option 1: numeric mapping</span>

            <span class="s0">if </span>map_type == <span class="s3">&quot;numeric&quot;</span>:

                levels, lookup_table, norm = self.numeric_mapping(
                    data, sizes, norm,
                )

            <span class="s2"># --- Option 2: categorical mapping</span>

            <span class="s0">elif </span>map_type == <span class="s3">&quot;categorical&quot;</span>:

                levels, lookup_table = self.categorical_mapping(
                    data, sizes, order,
                )

            <span class="s2"># --- Option 3: datetime mapping</span>

            <span class="s2"># TODO this needs an actual implementation</span>
            <span class="s0">else</span>:

                levels, lookup_table = self.categorical_mapping(
                    <span class="s2"># Casting data to list to handle differences in the way</span>
                    <span class="s2"># pandas and numpy represent datetime64 data</span>
                    list(data), sizes, order,
                )

            self.map_type = map_type
            self.levels = levels
            self.norm = norm
            self.sizes = sizes
            self.lookup_table = lookup_table

    <span class="s0">def </span>infer_map_type(self, norm, sizes, var_type):

        <span class="s0">if </span>norm <span class="s0">is not None</span>:
            map_type = <span class="s3">&quot;numeric&quot;</span>
        <span class="s0">elif </span>isinstance(sizes, (dict, list)):
            map_type = <span class="s3">&quot;categorical&quot;</span>
        <span class="s0">else</span>:
            map_type = var_type

        <span class="s0">return </span>map_type

    <span class="s0">def </span>_lookup_single(self, key):

        <span class="s0">try</span>:
            value = self.lookup_table[key]
        <span class="s0">except </span>KeyError:
            normed = self.norm(key)
            <span class="s0">if </span>np.ma.is_masked(normed):
                normed = np.nan
            size_values = self.lookup_table.values()
            size_range = min(size_values), max(size_values)
            value = size_range[<span class="s4">0</span>] + normed * np.ptp(size_range)
        <span class="s0">return </span>value

    <span class="s0">def </span>categorical_mapping(self, data, sizes, order):

        levels = categorical_order(data, order)

        <span class="s0">if </span>isinstance(sizes, dict):

            <span class="s2"># Dict inputs map existing data values to the size attribute</span>
            missing = set(levels) - set(sizes)
            <span class="s0">if </span>any(missing):
                err = <span class="s3">f&quot;Missing sizes for the following levels: </span><span class="s0">{</span>missing<span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s0">raise </span>ValueError(err)
            lookup_table = sizes.copy()

        <span class="s0">elif </span>isinstance(sizes, list):

            <span class="s2"># List inputs give size values in the same order as the levels</span>
            <span class="s0">if </span>len(sizes) != len(levels):
                err = <span class="s3">&quot;The `sizes` list has the wrong number of values.&quot;</span>
                <span class="s0">raise </span>ValueError(err)

            lookup_table = dict(zip(levels, sizes))

        <span class="s0">else</span>:

            <span class="s0">if </span>isinstance(sizes, tuple):

                <span class="s2"># Tuple input sets the min, max size values</span>
                <span class="s0">if </span>len(sizes) != <span class="s4">2</span>:
                    err = <span class="s3">&quot;A `sizes` tuple must have only 2 values&quot;</span>
                    <span class="s0">raise </span>ValueError(err)

            <span class="s0">elif </span>sizes <span class="s0">is not None</span>:

                err = <span class="s3">f&quot;Value for `sizes` not understood: </span><span class="s0">{</span>sizes<span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s0">raise </span>ValueError(err)

            <span class="s0">else</span>:

                <span class="s2"># Otherwise, we need to get the min, max size values from</span>
                <span class="s2"># the plotter object we are attached to.</span>

                <span class="s2"># TODO this is going to cause us trouble later, because we</span>
                <span class="s2"># want to restructure things so that the plotter is generic</span>
                <span class="s2"># across the visual representation of the data. But at this</span>
                <span class="s2"># point, we don't know the visual representation. Likely we</span>
                <span class="s2"># want to change the logic of this Mapping so that it gives</span>
                <span class="s2"># points on a nornalized range that then gets unnormalized</span>
                <span class="s2"># when we know what we're drawing. But given the way the</span>
                <span class="s2"># package works now, this way is cleanest.</span>
                sizes = self.plotter._default_size_range

            <span class="s2"># For categorical sizes, use regularly-spaced linear steps</span>
            <span class="s2"># between the minimum and maximum sizes. Then reverse the</span>
            <span class="s2"># ramp so that the largest value is used for the first entry</span>
            <span class="s2"># in size_order, etc. This is because &quot;ordered&quot; categoricals</span>
            <span class="s2"># are often though to go in decreasing priority.</span>
            sizes = np.linspace(*sizes, len(levels))[::-<span class="s4">1</span>]
            lookup_table = dict(zip(levels, sizes))

        <span class="s0">return </span>levels, lookup_table

    <span class="s0">def </span>numeric_mapping(self, data, sizes, norm):

        <span class="s0">if </span>isinstance(sizes, dict):
            <span class="s2"># The presence of a norm object overrides a dictionary of sizes</span>
            <span class="s2"># in specifying a numeric mapping, so we need to process it</span>
            <span class="s2"># dictionary here</span>
            levels = list(np.sort(list(sizes)))
            size_values = sizes.values()
            size_range = min(size_values), max(size_values)

        <span class="s0">else</span>:

            <span class="s2"># The levels here will be the unique values in the data</span>
            levels = list(np.sort(remove_na(data.unique())))

            <span class="s0">if </span>isinstance(sizes, tuple):

                <span class="s2"># For numeric inputs, the size can be parametrized by</span>
                <span class="s2"># the minimum and maximum artist values to map to. The</span>
                <span class="s2"># norm object that gets set up next specifies how to</span>
                <span class="s2"># do the mapping.</span>

                <span class="s0">if </span>len(sizes) != <span class="s4">2</span>:
                    err = <span class="s3">&quot;A `sizes` tuple must have only 2 values&quot;</span>
                    <span class="s0">raise </span>ValueError(err)

                size_range = sizes

            <span class="s0">elif </span>sizes <span class="s0">is not None</span>:

                err = <span class="s3">f&quot;Value for `sizes` not understood: </span><span class="s0">{</span>sizes<span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s0">raise </span>ValueError(err)

            <span class="s0">else</span>:

                <span class="s2"># When not provided, we get the size range from the plotter</span>
                <span class="s2"># object we are attached to. See the note in the categorical</span>
                <span class="s2"># method about how this is suboptimal for future development.:</span>
                size_range = self.plotter._default_size_range

        <span class="s2"># Now that we know the minimum and maximum sizes that will get drawn,</span>
        <span class="s2"># we need to map the data values that we have into that range. We will</span>
        <span class="s2"># use a matplotlib Normalize class, which is typically used for numeric</span>
        <span class="s2"># color mapping but works fine here too. It takes data values and maps</span>
        <span class="s2"># them into a [0, 1] interval, potentially nonlinear-ly.</span>

        <span class="s0">if </span>norm <span class="s0">is None</span>:
            <span class="s2"># Default is a linear function between the min and max data values</span>
            norm = mpl.colors.Normalize()
        <span class="s0">elif </span>isinstance(norm, tuple):
            <span class="s2"># It is also possible to give different limits in data space</span>
            norm = mpl.colors.Normalize(*norm)
        <span class="s0">elif not </span>isinstance(norm, mpl.colors.Normalize):
            err = <span class="s3">f&quot;Value for size `norm` parameter not understood: </span><span class="s0">{</span>norm<span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s0">raise </span>ValueError(err)
        <span class="s0">else</span>:
            <span class="s2"># If provided with Normalize object, copy it so we can modify</span>
            norm = copy(norm)

        <span class="s2"># Set the mapping so all output values are in [0, 1]</span>
        norm.clip = <span class="s0">True</span>

        <span class="s2"># If the input range is not set, use the full range of the data</span>
        <span class="s0">if not </span>norm.scaled():
            norm(levels)

        <span class="s2"># Map from data values to [0, 1] range</span>
        sizes_scaled = norm(levels)

        <span class="s2"># Now map from the scaled range into the artist units</span>
        <span class="s0">if </span>isinstance(sizes, dict):
            lookup_table = sizes
        <span class="s0">else</span>:
            lo, hi = size_range
            sizes = lo + sizes_scaled * (hi - lo)
            lookup_table = dict(zip(levels, sizes))

        <span class="s0">return </span>levels, lookup_table, norm


@share_init_params_with_map
<span class="s0">class </span>StyleMapping(SemanticMapping):
    <span class="s2">&quot;&quot;&quot;Mapping that sets artist style according to data values.&quot;&quot;&quot;</span>

    <span class="s2"># Style mapping is always treated as categorical</span>
    map_type = <span class="s3">&quot;categorical&quot;</span>

    <span class="s0">def </span>__init__(
        self, plotter, markers=<span class="s0">None</span>, dashes=<span class="s0">None</span>, order=<span class="s0">None</span>,
    ):
        <span class="s2">&quot;&quot;&quot;Map the levels of the `style` variable to distinct values. 
 
        Parameters 
        ---------- 
        # TODO add generic parameters 
 
        &quot;&quot;&quot;</span>
        super().__init__(plotter)

        data = plotter.plot_data.get(<span class="s3">&quot;style&quot;</span>, pd.Series(dtype=float))

        <span class="s0">if </span>data.notna().any():

            <span class="s2"># Cast to list to handle numpy/pandas datetime quirks</span>
            <span class="s0">if </span>variable_type(data) == <span class="s3">&quot;datetime&quot;</span>:
                data = list(data)

            <span class="s2"># Find ordered unique values</span>
            levels = categorical_order(data, order)

            markers = self._map_attributes(
                markers, levels, unique_markers(len(levels)), <span class="s3">&quot;markers&quot;</span>,
            )
            dashes = self._map_attributes(
                dashes, levels, unique_dashes(len(levels)), <span class="s3">&quot;dashes&quot;</span>,
            )

            <span class="s2"># Build the paths matplotlib will use to draw the markers</span>
            paths = {}
            filled_markers = []
            <span class="s0">for </span>k, m <span class="s0">in </span>markers.items():
                <span class="s0">if not </span>isinstance(m, mpl.markers.MarkerStyle):
                    m = mpl.markers.MarkerStyle(m)
                paths[k] = m.get_path().transformed(m.get_transform())
                filled_markers.append(m.is_filled())

            <span class="s2"># Mixture of filled and unfilled markers will show line art markers</span>
            <span class="s2"># in the edge color, which defaults to white. This can be handled,</span>
            <span class="s2"># but there would be additional complexity with specifying the</span>
            <span class="s2"># weight of the line art markers without overwhelming the filled</span>
            <span class="s2"># ones with the edges. So for now, we will disallow mixtures.</span>
            <span class="s0">if </span>any(filled_markers) <span class="s0">and not </span>all(filled_markers):
                err = <span class="s3">&quot;Filled and line art markers cannot be mixed&quot;</span>
                <span class="s0">raise </span>ValueError(err)

            lookup_table = {}
            <span class="s0">for </span>key <span class="s0">in </span>levels:
                lookup_table[key] = {}
                <span class="s0">if </span>markers:
                    lookup_table[key][<span class="s3">&quot;marker&quot;</span>] = markers[key]
                    lookup_table[key][<span class="s3">&quot;path&quot;</span>] = paths[key]
                <span class="s0">if </span>dashes:
                    lookup_table[key][<span class="s3">&quot;dashes&quot;</span>] = dashes[key]

            self.levels = levels
            self.lookup_table = lookup_table

    <span class="s0">def </span>_lookup_single(self, key, attr=<span class="s0">None</span>):
        <span class="s2">&quot;&quot;&quot;Get attribute(s) for a given data point.&quot;&quot;&quot;</span>
        <span class="s0">if </span>attr <span class="s0">is None</span>:
            value = self.lookup_table[key]
        <span class="s0">else</span>:
            value = self.lookup_table[key][attr]
        <span class="s0">return </span>value

    <span class="s0">def </span>_map_attributes(self, arg, levels, defaults, attr):
        <span class="s2">&quot;&quot;&quot;Handle the specification for a given style attribute.&quot;&quot;&quot;</span>
        <span class="s0">if </span>arg <span class="s0">is True</span>:
            lookup_table = dict(zip(levels, defaults))
        <span class="s0">elif </span>isinstance(arg, dict):
            missing = set(levels) - set(arg)
            <span class="s0">if </span>missing:
                err = <span class="s3">f&quot;These `</span><span class="s0">{</span>attr<span class="s0">}</span><span class="s3">` levels are missing values: </span><span class="s0">{</span>missing<span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s0">raise </span>ValueError(err)
            lookup_table = arg
        <span class="s0">elif </span>isinstance(arg, Sequence):
            <span class="s0">if </span>len(levels) != len(arg):
                err = <span class="s3">f&quot;The `</span><span class="s0">{</span>attr<span class="s0">}</span><span class="s3">` argument has the wrong number of values&quot;</span>
                <span class="s0">raise </span>ValueError(err)
            lookup_table = dict(zip(levels, arg))
        <span class="s0">elif </span>arg:
            err = <span class="s3">f&quot;This `</span><span class="s0">{</span>attr<span class="s0">}</span><span class="s3">` argument was not understood: </span><span class="s0">{</span>arg<span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s0">raise </span>ValueError(err)
        <span class="s0">else</span>:
            lookup_table = {}

        <span class="s0">return </span>lookup_table


<span class="s2"># =========================================================================== #</span>


<span class="s0">class </span>VectorPlotter:
    <span class="s2">&quot;&quot;&quot;Base class for objects underlying *plot functions.&quot;&quot;&quot;</span>

    _semantic_mappings = {
        <span class="s3">&quot;hue&quot;</span>: HueMapping,
        <span class="s3">&quot;size&quot;</span>: SizeMapping,
        <span class="s3">&quot;style&quot;</span>: StyleMapping,
    }

    <span class="s2"># TODO units is another example of a non-mapping &quot;semantic&quot;</span>
    <span class="s2"># we need a general name for this and separate handling</span>
    semantics = <span class="s3">&quot;x&quot;</span>, <span class="s3">&quot;y&quot;</span>, <span class="s3">&quot;hue&quot;</span>, <span class="s3">&quot;size&quot;</span>, <span class="s3">&quot;style&quot;</span>, <span class="s3">&quot;units&quot;</span>
    wide_structure = {
        <span class="s3">&quot;x&quot;</span>: <span class="s3">&quot;@index&quot;</span>, <span class="s3">&quot;y&quot;</span>: <span class="s3">&quot;@values&quot;</span>, <span class="s3">&quot;hue&quot;</span>: <span class="s3">&quot;@columns&quot;</span>, <span class="s3">&quot;style&quot;</span>: <span class="s3">&quot;@columns&quot;</span>,
    }
    flat_structure = {<span class="s3">&quot;x&quot;</span>: <span class="s3">&quot;@index&quot;</span>, <span class="s3">&quot;y&quot;</span>: <span class="s3">&quot;@values&quot;</span>}

    _default_size_range = <span class="s4">1</span>, <span class="s4">2  </span><span class="s2"># Unused but needed in tests, ugh</span>

    <span class="s0">def </span>__init__(self, data=<span class="s0">None</span>, variables={}):

        self.assign_variables(data, variables)

        <span class="s0">for </span>var, cls <span class="s0">in </span>self._semantic_mappings.items():

            <span class="s2"># Create the mapping function</span>
            map_func = partial(cls.map, plotter=self)
            setattr(self, <span class="s3">f&quot;map_</span><span class="s0">{</span>var<span class="s0">}</span><span class="s3">&quot;</span>, map_func)

            <span class="s2"># Call the mapping function to initialize with default values</span>
            getattr(self, <span class="s3">f&quot;map_</span><span class="s0">{</span>var<span class="s0">}</span><span class="s3">&quot;</span>)()

        self._var_levels = {}

    @classmethod
    <span class="s0">def </span>get_semantics(cls, kwargs, semantics=<span class="s0">None</span>):
        <span class="s2">&quot;&quot;&quot;Subset a dictionary` arguments with known semantic variables.&quot;&quot;&quot;</span>
        <span class="s2"># TODO this should be get_variables since we have included x and y</span>
        <span class="s0">if </span>semantics <span class="s0">is None</span>:
            semantics = cls.semantics
        variables = {}
        <span class="s0">for </span>key, val <span class="s0">in </span>kwargs.items():
            <span class="s0">if </span>key <span class="s0">in </span>semantics <span class="s0">and </span>val <span class="s0">is not None</span>:
                variables[key] = val
        <span class="s0">return </span>variables

    @property
    <span class="s0">def </span>has_xy_data(self):
        <span class="s2">&quot;&quot;&quot;Return True at least one of x or y is defined.&quot;&quot;&quot;</span>
        <span class="s0">return </span>bool({<span class="s3">&quot;x&quot;</span>, <span class="s3">&quot;y&quot;</span>} &amp; set(self.variables))

    @property
    <span class="s0">def </span>var_levels(self):
        <span class="s2">&quot;&quot;&quot;Property interface to ordered list of variables levels. 
 
        Each time it's accessed, it updates the var_levels dictionary with the 
        list of levels in the current semantic mappers. But it also allows the 
        dictionary to persist, so it can be used to set levels by a key. This is 
        used to track the list of col/row levels using an attached FacetGrid 
        object, but it's kind of messy and ideally fixed by improving the 
        faceting logic so it interfaces better with the modern approach to 
        tracking plot variables. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span>var <span class="s0">in </span>self.variables:
            <span class="s0">try</span>:
                map_obj = getattr(self, <span class="s3">f&quot;_</span><span class="s0">{</span>var<span class="s0">}</span><span class="s3">_map&quot;</span>)
                self._var_levels[var] = map_obj.levels
            <span class="s0">except </span>AttributeError:
                <span class="s0">pass</span>
        <span class="s0">return </span>self._var_levels

    <span class="s0">def </span>assign_variables(self, data=<span class="s0">None</span>, variables={}):
        <span class="s2">&quot;&quot;&quot;Define plot variables, optionally using lookup from `data`.&quot;&quot;&quot;</span>
        x = variables.get(<span class="s3">&quot;x&quot;</span>, <span class="s0">None</span>)
        y = variables.get(<span class="s3">&quot;y&quot;</span>, <span class="s0">None</span>)

        <span class="s0">if </span>x <span class="s0">is None and </span>y <span class="s0">is None</span>:
            self.input_format = <span class="s3">&quot;wide&quot;</span>
            plot_data, variables = self._assign_variables_wideform(
                data, **variables,
            )
        <span class="s0">else</span>:
            self.input_format = <span class="s3">&quot;long&quot;</span>
            plot_data, variables = self._assign_variables_longform(
                data, **variables,
            )

        self.plot_data = plot_data
        self.variables = variables
        self.var_types = {
            v: variable_type(
                plot_data[v],
                boolean_type=<span class="s3">&quot;numeric&quot; </span><span class="s0">if </span>v <span class="s0">in </span><span class="s3">&quot;xy&quot; </span><span class="s0">else </span><span class="s3">&quot;categorical&quot;</span>
            )
            <span class="s0">for </span>v <span class="s0">in </span>variables
        }

        <span class="s0">return </span>self

    <span class="s0">def </span>_assign_variables_wideform(self, data=<span class="s0">None</span>, **kwargs):
        <span class="s2">&quot;&quot;&quot;Define plot variables given wide-form data. 
 
        Parameters 
        ---------- 
        data : flat vector or collection of vectors 
            Data can be a vector or mapping that is coerceable to a Series 
            or a sequence- or mapping-based collection of such vectors, or a 
            rectangular numpy array, or a Pandas DataFrame. 
        kwargs : variable -&gt; data mappings 
            Behavior with keyword arguments is currently undefined. 
 
        Returns 
        ------- 
        plot_data : :class:`pandas.DataFrame` 
            Long-form data object mapping seaborn variables (x, y, hue, ...) 
            to data vectors. 
        variables : dict 
            Keys are defined seaborn variables; values are names inferred from 
            the inputs (or None when no name can be determined). 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># Raise if semantic or other variables are assigned in wide-form mode</span>
        assigned = [k <span class="s0">for </span>k, v <span class="s0">in </span>kwargs.items() <span class="s0">if </span>v <span class="s0">is not None</span>]
        <span class="s0">if </span>any(assigned):
            s = <span class="s3">&quot;s&quot; </span><span class="s0">if </span>len(assigned) &gt; <span class="s4">1 </span><span class="s0">else </span><span class="s3">&quot;&quot;</span>
            err = <span class="s3">f&quot;The following variable</span><span class="s0">{</span>s<span class="s0">} </span><span class="s3">cannot be assigned with wide-form data: &quot;</span>
            err += <span class="s3">&quot;, &quot;</span>.join(<span class="s3">f&quot;`</span><span class="s0">{</span>v<span class="s0">}</span><span class="s3">`&quot; </span><span class="s0">for </span>v <span class="s0">in </span>assigned)
            <span class="s0">raise </span>ValueError(err)

        <span class="s2"># Determine if the data object actually has any data in it</span>
        empty = data <span class="s0">is None or not </span>len(data)

        <span class="s2"># Then, determine if we have &quot;flat&quot; data (a single vector)</span>
        <span class="s0">if </span>isinstance(data, dict):
            values = data.values()
        <span class="s0">else</span>:
            values = np.atleast_1d(np.asarray(data, dtype=object))
        flat = <span class="s0">not </span>any(
            isinstance(v, Iterable) <span class="s0">and not </span>isinstance(v, (str, bytes))
            <span class="s0">for </span>v <span class="s0">in </span>values
        )

        <span class="s0">if </span>empty:

            <span class="s2"># Make an object with the structure of plot_data, but empty</span>
            plot_data = pd.DataFrame()
            variables = {}

        <span class="s0">elif </span>flat:

            <span class="s2"># Handle flat data by converting to pandas Series and using the</span>
            <span class="s2"># index and/or values to define x and/or y</span>
            <span class="s2"># (Could be accomplished with a more general to_series() interface)</span>
            flat_data = pd.Series(data).copy()
            names = {
                <span class="s3">&quot;@values&quot;</span>: flat_data.name,
                <span class="s3">&quot;@index&quot;</span>: flat_data.index.name
            }

            plot_data = {}
            variables = {}

            <span class="s0">for </span>var <span class="s0">in </span>[<span class="s3">&quot;x&quot;</span>, <span class="s3">&quot;y&quot;</span>]:
                <span class="s0">if </span>var <span class="s0">in </span>self.flat_structure:
                    attr = self.flat_structure[var]
                    plot_data[var] = getattr(flat_data, attr[<span class="s4">1</span>:])
                    variables[var] = names[self.flat_structure[var]]

            plot_data = pd.DataFrame(plot_data)

        <span class="s0">else</span>:

            <span class="s2"># Otherwise assume we have some collection of vectors.</span>

            <span class="s2"># Handle Python sequences such that entries end up in the columns,</span>
            <span class="s2"># not in the rows, of the intermediate wide DataFrame.</span>
            <span class="s2"># One way to accomplish this is to convert to a dict of Series.</span>
            <span class="s0">if </span>isinstance(data, Sequence):
                data_dict = {}
                <span class="s0">for </span>i, var <span class="s0">in </span>enumerate(data):
                    key = getattr(var, <span class="s3">&quot;name&quot;</span>, i)
                    <span class="s2"># TODO is there a safer/more generic way to ensure Series?</span>
                    <span class="s2"># sort of like np.asarray, but for pandas?</span>
                    data_dict[key] = pd.Series(var)

                data = data_dict

            <span class="s2"># Pandas requires that dict values either be Series objects</span>
            <span class="s2"># or all have the same length, but we want to allow &quot;ragged&quot; inputs</span>
            <span class="s0">if </span>isinstance(data, Mapping):
                data = {key: pd.Series(val) <span class="s0">for </span>key, val <span class="s0">in </span>data.items()}

            <span class="s2"># Otherwise, delegate to the pandas DataFrame constructor</span>
            <span class="s2"># This is where we'd prefer to use a general interface that says</span>
            <span class="s2"># &quot;give me this data as a pandas DataFrame&quot;, so we can accept</span>
            <span class="s2"># DataFrame objects from other libraries</span>
            wide_data = pd.DataFrame(data, copy=<span class="s0">True</span>)

            <span class="s2"># At this point we should reduce the dataframe to numeric cols</span>
            numeric_cols = wide_data.apply(variable_type) == <span class="s3">&quot;numeric&quot;</span>
            wide_data = wide_data.loc[:, numeric_cols]

            <span class="s2"># Now melt the data to long form</span>
            melt_kws = {<span class="s3">&quot;var_name&quot;</span>: <span class="s3">&quot;@columns&quot;</span>, <span class="s3">&quot;value_name&quot;</span>: <span class="s3">&quot;@values&quot;</span>}
            use_index = <span class="s3">&quot;@index&quot; </span><span class="s0">in </span>self.wide_structure.values()
            <span class="s0">if </span>use_index:
                melt_kws[<span class="s3">&quot;id_vars&quot;</span>] = <span class="s3">&quot;@index&quot;</span>
                <span class="s0">try</span>:
                    orig_categories = wide_data.columns.categories
                    orig_ordered = wide_data.columns.ordered
                    wide_data.columns = wide_data.columns.add_categories(<span class="s3">&quot;@index&quot;</span>)
                <span class="s0">except </span>AttributeError:
                    category_columns = <span class="s0">False</span>
                <span class="s0">else</span>:
                    category_columns = <span class="s0">True</span>
                wide_data[<span class="s3">&quot;@index&quot;</span>] = wide_data.index.to_series()

            plot_data = wide_data.melt(**melt_kws)

            <span class="s0">if </span>use_index <span class="s0">and </span>category_columns:
                plot_data[<span class="s3">&quot;@columns&quot;</span>] = pd.Categorical(plot_data[<span class="s3">&quot;@columns&quot;</span>],
                                                       orig_categories,
                                                       orig_ordered)

            <span class="s2"># Assign names corresponding to plot semantics</span>
            <span class="s0">for </span>var, attr <span class="s0">in </span>self.wide_structure.items():
                plot_data[var] = plot_data[attr]

            <span class="s2"># Define the variable names</span>
            variables = {}
            <span class="s0">for </span>var, attr <span class="s0">in </span>self.wide_structure.items():
                obj = getattr(wide_data, attr[<span class="s4">1</span>:])
                variables[var] = getattr(obj, <span class="s3">&quot;name&quot;</span>, <span class="s0">None</span>)

            <span class="s2"># Remove redundant columns from plot_data</span>
            plot_data = plot_data[list(variables)]

        <span class="s0">return </span>plot_data, variables

    <span class="s0">def </span>_assign_variables_longform(self, data=<span class="s0">None</span>, **kwargs):
        <span class="s2">&quot;&quot;&quot;Define plot variables given long-form data and/or vector inputs. 
 
        Parameters 
        ---------- 
        data : dict-like collection of vectors 
            Input data where variable names map to vector values. 
        kwargs : variable -&gt; data mappings 
            Keys are seaborn variables (x, y, hue, ...) and values are vectors 
            in any format that can construct a :class:`pandas.DataFrame` or 
            names of columns or index levels in ``data``. 
 
        Returns 
        ------- 
        plot_data : :class:`pandas.DataFrame` 
            Long-form data object mapping seaborn variables (x, y, hue, ...) 
            to data vectors. 
        variables : dict 
            Keys are defined seaborn variables; values are names inferred from 
            the inputs (or None when no name can be determined). 
 
        Raises 
        ------ 
        ValueError 
            When variables are strings that don't appear in ``data``. 
 
        &quot;&quot;&quot;</span>
        plot_data = {}
        variables = {}

        <span class="s2"># Data is optional; all variables can be defined as vectors</span>
        <span class="s0">if </span>data <span class="s0">is None</span>:
            data = {}

        <span class="s2"># TODO should we try a data.to_dict() or similar here to more</span>
        <span class="s2"># generally accept objects with that interface?</span>
        <span class="s2"># Note that dict(df) also works for pandas, and gives us what we</span>
        <span class="s2"># want, whereas DataFrame.to_dict() gives a nested dict instead of</span>
        <span class="s2"># a dict of series.</span>

        <span class="s2"># Variables can also be extraced from the index attribute</span>
        <span class="s2"># TODO is this the most general way to enable it?</span>
        <span class="s2"># There is no index.to_dict on multiindex, unfortunately</span>
        <span class="s0">try</span>:
            index = data.index.to_frame()
        <span class="s0">except </span>AttributeError:
            index = {}

        <span class="s2"># The caller will determine the order of variables in plot_data</span>
        <span class="s0">for </span>key, val <span class="s0">in </span>kwargs.items():

            <span class="s2"># First try to treat the argument as a key for the data collection.</span>
            <span class="s2"># But be flexible about what can be used as a key.</span>
            <span class="s2"># Usually it will be a string, but allow numbers or tuples too when</span>
            <span class="s2"># taking from the main data object. Only allow strings to reference</span>
            <span class="s2"># fields in the index, because otherwise there is too much ambiguity.</span>
            <span class="s0">try</span>:
                val_as_data_key = (
                    val <span class="s0">in </span>data
                    <span class="s0">or </span>(isinstance(val, (str, bytes)) <span class="s0">and </span>val <span class="s0">in </span>index)
                )
            <span class="s0">except </span>(KeyError, TypeError):
                val_as_data_key = <span class="s0">False</span>

            <span class="s0">if </span>val_as_data_key:

                <span class="s2"># We know that __getitem__ will work</span>

                <span class="s0">if </span>val <span class="s0">in </span>data:
                    plot_data[key] = data[val]
                <span class="s0">elif </span>val <span class="s0">in </span>index:
                    plot_data[key] = index[val]
                variables[key] = val

            <span class="s0">elif </span>isinstance(val, (str, bytes)):

                <span class="s2"># This looks like a column name but we don't know what it means!</span>

                err = <span class="s3">f&quot;Could not interpret value `</span><span class="s0">{</span>val<span class="s0">}</span><span class="s3">` for parameter `</span><span class="s0">{</span>key<span class="s0">}</span><span class="s3">`&quot;</span>
                <span class="s0">raise </span>ValueError(err)

            <span class="s0">else</span>:

                <span class="s2"># Otherwise, assume the value is itself data</span>

                <span class="s2"># Raise when data object is present and a vector can't matched</span>
                <span class="s0">if </span>isinstance(data, pd.DataFrame) <span class="s0">and not </span>isinstance(val, pd.Series):
                    <span class="s0">if </span>np.ndim(val) <span class="s0">and </span>len(data) != len(val):
                        val_cls = val.__class__.__name__
                        err = (
                            <span class="s3">f&quot;Length of </span><span class="s0">{</span>val_cls<span class="s0">} </span><span class="s3">vectors must match length of `data`&quot;</span>
                            <span class="s3">f&quot; when both are used, but `data` has length </span><span class="s0">{</span>len(data)<span class="s0">}</span><span class="s3">&quot;</span>
                            <span class="s3">f&quot; and the vector passed to `</span><span class="s0">{</span>key<span class="s0">}</span><span class="s3">` has length </span><span class="s0">{</span>len(val)<span class="s0">}</span><span class="s3">.&quot;</span>
                        )
                        <span class="s0">raise </span>ValueError(err)

                plot_data[key] = val

                <span class="s2"># Try to infer the name of the variable</span>
                variables[key] = getattr(val, <span class="s3">&quot;name&quot;</span>, <span class="s0">None</span>)

        <span class="s2"># Construct a tidy plot DataFrame. This will convert a number of</span>
        <span class="s2"># types automatically, aligning on index in case of pandas objects</span>
        plot_data = pd.DataFrame(plot_data)

        <span class="s2"># Reduce the variables dictionary to fields with valid data</span>
        variables = {
            var: name
            <span class="s0">for </span>var, name <span class="s0">in </span>variables.items()
            <span class="s0">if </span>plot_data[var].notnull().any()
        }

        <span class="s0">return </span>plot_data, variables

    <span class="s0">def </span>iter_data(
        self, grouping_vars=<span class="s0">None</span>, reverse=<span class="s0">False</span>, from_comp_data=<span class="s0">False</span>,
    ):
        <span class="s2">&quot;&quot;&quot;Generator for getting subsets of data defined by semantic variables. 
 
        Also injects &quot;col&quot; and &quot;row&quot; into grouping semantics. 
 
        Parameters 
        ---------- 
        grouping_vars : string or list of strings 
            Semantic variables that define the subsets of data. 
        reverse : bool, optional 
            If True, reverse the order of iteration. 
        from_comp_data : bool, optional 
            If True, use self.comp_data rather than self.plot_data 
 
        Yields 
        ------ 
        sub_vars : dict 
            Keys are semantic names, values are the level of that semantic. 
        sub_data : :class:`pandas.DataFrame` 
            Subset of ``plot_data`` for this combination of semantic values. 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># TODO should this default to using all (non x/y?) semantics?</span>
        <span class="s2"># or define groupping vars somewhere?</span>
        <span class="s0">if </span>grouping_vars <span class="s0">is None</span>:
            grouping_vars = []
        <span class="s0">elif </span>isinstance(grouping_vars, str):
            grouping_vars = [grouping_vars]
        <span class="s0">elif </span>isinstance(grouping_vars, tuple):
            grouping_vars = list(grouping_vars)

        <span class="s2"># Always insert faceting variables</span>
        facet_vars = {<span class="s3">&quot;col&quot;</span>, <span class="s3">&quot;row&quot;</span>}
        grouping_vars.extend(
            facet_vars &amp; set(self.variables) - set(grouping_vars)
        )

        <span class="s2"># Reduce to the semantics used in this plot</span>
        grouping_vars = [
            var <span class="s0">for </span>var <span class="s0">in </span>grouping_vars <span class="s0">if </span>var <span class="s0">in </span>self.variables
        ]

        <span class="s0">if </span>from_comp_data:
            data = self.comp_data
        <span class="s0">else</span>:
            data = self.plot_data

        <span class="s0">if </span>grouping_vars:

            grouped_data = data.groupby(
                grouping_vars, sort=<span class="s0">False</span>, as_index=<span class="s0">False</span>
            )

            grouping_keys = []
            <span class="s0">for </span>var <span class="s0">in </span>grouping_vars:
                grouping_keys.append(self.var_levels.get(var, []))

            iter_keys = itertools.product(*grouping_keys)
            <span class="s0">if </span>reverse:
                iter_keys = reversed(list(iter_keys))

            <span class="s0">for </span>key <span class="s0">in </span>iter_keys:

                <span class="s2"># Pandas fails with singleton tuple inputs</span>
                pd_key = key[<span class="s4">0</span>] <span class="s0">if </span>len(key) == <span class="s4">1 </span><span class="s0">else </span>key

                <span class="s0">try</span>:
                    data_subset = grouped_data.get_group(pd_key)
                <span class="s0">except </span>KeyError:
                    <span class="s0">continue</span>

                sub_vars = dict(zip(grouping_vars, key))

                <span class="s0">yield </span>sub_vars, data_subset

        <span class="s0">else</span>:

            <span class="s0">yield </span>{}, data

    @property
    <span class="s0">def </span>comp_data(self):
        <span class="s2">&quot;&quot;&quot;Dataframe with numeric x and y, after unit conversion and log scaling.&quot;&quot;&quot;</span>
        <span class="s0">if not </span>hasattr(self, <span class="s3">&quot;ax&quot;</span>):
            <span class="s2"># Probably a good idea, but will need a bunch of tests updated</span>
            <span class="s2"># Most of these tests should just use the external interface</span>
            <span class="s2"># Then this can be re-enabled.</span>
            <span class="s2"># raise AttributeError(&quot;No Axes attached to plotter&quot;)</span>
            <span class="s0">return </span>self.plot_data

        <span class="s0">if not </span>hasattr(self, <span class="s3">&quot;_comp_data&quot;</span>):

            comp_data = (
                self.plot_data
                .copy(deep=<span class="s0">False</span>)
                .drop([<span class="s3">&quot;x&quot;</span>, <span class="s3">&quot;y&quot;</span>], axis=<span class="s4">1</span>, errors=<span class="s3">&quot;ignore&quot;</span>)
            )
            <span class="s0">for </span>var <span class="s0">in </span><span class="s3">&quot;yx&quot;</span>:
                <span class="s0">if </span>var <span class="s0">not in </span>self.variables:
                    <span class="s0">continue</span>

                <span class="s2"># Get a corresponding axis object so that we can convert the units</span>
                <span class="s2"># to matplotlib's numeric representation, which we can compute on</span>
                <span class="s2"># This is messy and it would probably be better for VectorPlotter</span>
                <span class="s2"># to manage its own converters (using the matplotlib tools).</span>
                <span class="s2"># XXX Currently does not support unshared categorical axes!</span>
                <span class="s2"># (But see comment in _attach about how those don't exist)</span>
                <span class="s0">if </span>self.ax <span class="s0">is None</span>:
                    ax = self.facets.axes.flat[<span class="s4">0</span>]
                <span class="s0">else</span>:
                    ax = self.ax
                axis = getattr(ax, <span class="s3">f&quot;</span><span class="s0">{</span>var<span class="s0">}</span><span class="s3">axis&quot;</span>)

                comp_var = axis.convert_units(self.plot_data[var])
                <span class="s0">if </span>axis.get_scale() == <span class="s3">&quot;log&quot;</span>:
                    comp_var = np.log10(comp_var)
                comp_data.insert(<span class="s4">0</span>, var, comp_var)

            self._comp_data = comp_data

        <span class="s0">return </span>self._comp_data

    <span class="s0">def </span>_get_axes(self, sub_vars):
        <span class="s2">&quot;&quot;&quot;Return an Axes object based on existence of row/col variables.&quot;&quot;&quot;</span>
        row = sub_vars.get(<span class="s3">&quot;row&quot;</span>, <span class="s0">None</span>)
        col = sub_vars.get(<span class="s3">&quot;col&quot;</span>, <span class="s0">None</span>)
        <span class="s0">if </span>row <span class="s0">is not None and </span>col <span class="s0">is not None</span>:
            <span class="s0">return </span>self.facets.axes_dict[(row, col)]
        <span class="s0">elif </span>row <span class="s0">is not None</span>:
            <span class="s0">return </span>self.facets.axes_dict[row]
        <span class="s0">elif </span>col <span class="s0">is not None</span>:
            <span class="s0">return </span>self.facets.axes_dict[col]
        <span class="s0">elif </span>self.ax <span class="s0">is None</span>:
            <span class="s0">return </span>self.facets.ax
        <span class="s0">else</span>:
            <span class="s0">return </span>self.ax

    <span class="s0">def </span>_attach(self, obj, allowed_types=<span class="s0">None</span>, log_scale=<span class="s0">None</span>):
        <span class="s2">&quot;&quot;&quot;Associate the plotter with an Axes manager and initialize its units. 
 
        Parameters 
        ---------- 
        obj : :class:`matplotlib.axes.Axes` or :class:'FacetGrid` 
            Structural object that we will eventually plot onto. 
        allowed_types : str or list of str 
            If provided, raise when either the x or y variable does not have 
            one of the declared seaborn types. 
        log_scale : bool, number, or pair of bools or numbers 
            If not False, set the axes to use log scaling, with the given 
            base or defaulting to 10. If a tuple, interpreted as separate 
            arguments for the x and y axes. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span>.axisgrid <span class="s0">import </span>FacetGrid
        <span class="s0">if </span>isinstance(obj, FacetGrid):
            self.ax = <span class="s0">None</span>
            self.facets = obj
            ax_list = obj.axes.flatten()
            <span class="s0">if </span>obj.col_names <span class="s0">is not None</span>:
                self.var_levels[<span class="s3">&quot;col&quot;</span>] = obj.col_names
            <span class="s0">if </span>obj.row_names <span class="s0">is not None</span>:
                self.var_levels[<span class="s3">&quot;row&quot;</span>] = obj.row_names
        <span class="s0">else</span>:
            self.ax = obj
            self.facets = <span class="s0">None</span>
            ax_list = [obj]

        <span class="s0">if </span>allowed_types <span class="s0">is None</span>:
            allowed_types = [<span class="s3">&quot;numeric&quot;</span>, <span class="s3">&quot;datetime&quot;</span>, <span class="s3">&quot;categorical&quot;</span>]
        <span class="s0">elif </span>isinstance(allowed_types, str):
            allowed_types = [allowed_types]

        <span class="s0">for </span>var <span class="s0">in </span>set(<span class="s3">&quot;xy&quot;</span>).intersection(self.variables):
            <span class="s2"># Check types of x/y variables</span>
            var_type = self.var_types[var]
            <span class="s0">if </span>var_type <span class="s0">not in </span>allowed_types:
                err = (
                    <span class="s3">f&quot;The </span><span class="s0">{</span>var<span class="s0">} </span><span class="s3">variable is </span><span class="s0">{</span>var_type<span class="s0">}</span><span class="s3">, but one of &quot;</span>
                    <span class="s3">f&quot;</span><span class="s0">{</span>allowed_types<span class="s0">} </span><span class="s3">is required&quot;</span>
                )
                <span class="s0">raise </span>TypeError(err)

            <span class="s2"># Register with the matplotlib unit conversion machinery</span>
            <span class="s2"># Perhaps cleaner to manage our own transform objects?</span>
            <span class="s2"># XXX Currently this does not allow &quot;unshared&quot; categorical axes</span>
            <span class="s2"># We could add metadata to a FacetGrid and set units based on that.</span>
            <span class="s2"># See also comment in comp_data, which only uses a single axes to do</span>
            <span class="s2"># its mapping, meaning that it won't handle unshared axes well either.</span>
            <span class="s0">for </span>ax <span class="s0">in </span>ax_list:
                axis = getattr(ax, <span class="s3">f&quot;</span><span class="s0">{</span>var<span class="s0">}</span><span class="s3">axis&quot;</span>)
                seed_data = self.plot_data[var]
                <span class="s0">if </span>var_type == <span class="s3">&quot;categorical&quot;</span>:
                    seed_data = categorical_order(seed_data)
                axis.update_units(seed_data)

        <span class="s2"># For categorical y, we want the &quot;first&quot; level to be at the top of the axis</span>
        <span class="s0">if </span>self.var_types.get(<span class="s3">&quot;y&quot;</span>, <span class="s0">None</span>) == <span class="s3">&quot;categorical&quot;</span>:
            <span class="s0">for </span>ax <span class="s0">in </span>ax_list:
                <span class="s0">try</span>:
                    ax.yaxis.set_inverted(<span class="s0">True</span>)
                <span class="s0">except </span>AttributeError:  <span class="s2"># mpl &lt; 3.1</span>
                    <span class="s0">if not </span>ax.yaxis_inverted():
                        ax.invert_yaxis()

        <span class="s2"># Possibly log-scale one or both axes</span>
        <span class="s0">if </span>log_scale <span class="s0">is not None</span>:
            <span class="s2"># Allow single value or x, y tuple</span>
            <span class="s0">try</span>:
                scalex, scaley = log_scale
            <span class="s0">except </span>TypeError:
                scalex = log_scale <span class="s0">if </span><span class="s3">&quot;x&quot; </span><span class="s0">in </span>self.variables <span class="s0">else False</span>
                scaley = log_scale <span class="s0">if </span><span class="s3">&quot;y&quot; </span><span class="s0">in </span>self.variables <span class="s0">else False</span>

            <span class="s0">for </span>axis, scale <span class="s0">in </span>zip(<span class="s3">&quot;xy&quot;</span>, (scalex, scaley)):
                <span class="s0">if </span>scale:
                    <span class="s0">for </span>ax <span class="s0">in </span>ax_list:
                        set_scale = getattr(ax, <span class="s3">f&quot;set_</span><span class="s0">{</span>axis<span class="s0">}</span><span class="s3">scale&quot;</span>)
                        <span class="s0">if </span>scale <span class="s0">is True</span>:
                            set_scale(<span class="s3">&quot;log&quot;</span>)
                        <span class="s0">else</span>:
                            <span class="s0">if </span>LooseVersion(mpl.__version__) &gt;= <span class="s3">&quot;3.3&quot;</span>:
                                set_scale(<span class="s3">&quot;log&quot;</span>, base=scale)
                            <span class="s0">else</span>:
                                set_scale(<span class="s3">&quot;log&quot;</span>, **{<span class="s3">f&quot;base</span><span class="s0">{</span>axis<span class="s0">}</span><span class="s3">&quot;</span>: scale})

    <span class="s0">def </span>_log_scaled(self, axis):
        <span class="s2">&quot;&quot;&quot;Return True if specified axis is log scaled on all attached axes.&quot;&quot;&quot;</span>
        <span class="s0">if </span>self.ax <span class="s0">is None</span>:
            axes_list = self.facets.axes.flatten()
        <span class="s0">else</span>:
            axes_list = [self.ax]

        log_scaled = []
        <span class="s0">for </span>ax <span class="s0">in </span>axes_list:
            data_axis = getattr(ax, <span class="s3">f&quot;</span><span class="s0">{</span>axis<span class="s0">}</span><span class="s3">axis&quot;</span>)
            log_scaled.append(data_axis.get_scale() == <span class="s3">&quot;log&quot;</span>)

        <span class="s0">if </span>any(log_scaled) <span class="s0">and not </span>all(log_scaled):
            <span class="s0">raise </span>RuntimeError(<span class="s3">&quot;Axis scaling is not consistent&quot;</span>)

        <span class="s0">return </span>any(log_scaled)

    <span class="s0">def </span>_add_axis_labels(self, ax, default_x=<span class="s3">&quot;&quot;</span>, default_y=<span class="s3">&quot;&quot;</span>):
        <span class="s2">&quot;&quot;&quot;Add axis labels if not present, set visibility to match ticklabels.&quot;&quot;&quot;</span>
        <span class="s2"># TODO ax could default to None and use attached axes if present</span>
        <span class="s2"># but what to do about the case of facets? Currently using FacetGrid's</span>
        <span class="s2"># set_axis_labels method, which doesn't add labels to the interior even</span>
        <span class="s2"># when the axes are not shared. Maybe that makes sense?</span>
        <span class="s0">if not </span>ax.get_xlabel():
            x_visible = any(t.get_visible() <span class="s0">for </span>t <span class="s0">in </span>ax.get_xticklabels())
            ax.set_xlabel(self.variables.get(<span class="s3">&quot;x&quot;</span>, default_x), visible=x_visible)
        <span class="s0">if not </span>ax.get_ylabel():
            y_visible = any(t.get_visible() <span class="s0">for </span>t <span class="s0">in </span>ax.get_yticklabels())
            ax.set_ylabel(self.variables.get(<span class="s3">&quot;y&quot;</span>, default_y), visible=y_visible)


<span class="s0">def </span>variable_type(vector, boolean_type=<span class="s3">&quot;numeric&quot;</span>):
    <span class="s2">&quot;&quot;&quot; 
    Determine whether a vector contains numeric, categorical, or datetime data. 
 
    This function differs from the pandas typing API in two ways: 
 
    - Python sequences or object-typed PyData objects are considered numeric if 
      all of their entries are numeric. 
    - String or mixed-type data are considered categorical even if not 
      explicitly represented as a :class:`pandas.api.types.CategoricalDtype`. 
 
    Parameters 
    ---------- 
    vector : :func:`pandas.Series`, :func:`numpy.ndarray`, or Python sequence 
        Input data to test. 
    boolean_type : 'numeric' or 'categorical' 
        Type to use for vectors containing only 0s and 1s (and NAs). 
 
    Returns 
    ------- 
    var_type : 'numeric', 'categorical', or 'datetime' 
        Name identifying the type of data in the vector. 
    &quot;&quot;&quot;</span>
    <span class="s2"># If a categorical dtype is set, infer categorical</span>
    <span class="s0">if </span>pd.api.types.is_categorical_dtype(vector):
        <span class="s0">return </span><span class="s3">&quot;categorical&quot;</span>

    <span class="s2"># Special-case all-na data, which is always &quot;numeric&quot;</span>
    <span class="s0">if </span>pd.isna(vector).all():
        <span class="s0">return </span><span class="s3">&quot;numeric&quot;</span>

    <span class="s2"># Special-case binary/boolean data, allow caller to determine</span>
    <span class="s2"># This triggers a numpy warning when vector has strings/objects</span>
    <span class="s2"># https://github.com/numpy/numpy/issues/6784</span>
    <span class="s2"># Because we reduce with .all(), we are agnostic about whether the</span>
    <span class="s2"># comparison returns a scalar or vector, so we will ignore the warning.</span>
    <span class="s2"># It triggers a separate DeprecationWarning when the vector has datetimes:</span>
    <span class="s2"># https://github.com/numpy/numpy/issues/13548</span>
    <span class="s2"># This is considered a bug by numpy and will likely go away.</span>
    <span class="s0">with </span>warnings.catch_warnings():
        warnings.simplefilter(
            action=<span class="s3">'ignore'</span>, category=(FutureWarning, DeprecationWarning)
        )
        <span class="s0">if </span>np.isin(vector, [<span class="s4">0</span>, <span class="s4">1</span>, np.nan]).all():
            <span class="s0">return </span>boolean_type

    <span class="s2"># Defer to positive pandas tests</span>
    <span class="s0">if </span>pd.api.types.is_numeric_dtype(vector):
        <span class="s0">return </span><span class="s3">&quot;numeric&quot;</span>

    <span class="s0">if </span>pd.api.types.is_datetime64_dtype(vector):
        <span class="s0">return </span><span class="s3">&quot;datetime&quot;</span>

    <span class="s2"># --- If we get to here, we need to check the entries</span>

    <span class="s2"># Check for a collection where everything is a number</span>

    <span class="s0">def </span>all_numeric(x):
        <span class="s0">for </span>x_i <span class="s0">in </span>x:
            <span class="s0">if not </span>isinstance(x_i, Number):
                <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">if </span>all_numeric(vector):
        <span class="s0">return </span><span class="s3">&quot;numeric&quot;</span>

    <span class="s2"># Check for a collection where everything is a datetime</span>

    <span class="s0">def </span>all_datetime(x):
        <span class="s0">for </span>x_i <span class="s0">in </span>x:
            <span class="s0">if not </span>isinstance(x_i, (datetime, np.datetime64)):
                <span class="s0">return False</span>
        <span class="s0">return True</span>

    <span class="s0">if </span>all_datetime(vector):
        <span class="s0">return </span><span class="s3">&quot;datetime&quot;</span>

    <span class="s2"># Otherwise, our final fallback is to consider things categorical</span>

    <span class="s0">return </span><span class="s3">&quot;categorical&quot;</span>


<span class="s0">def </span>infer_orient(x=<span class="s0">None</span>, y=<span class="s0">None</span>, orient=<span class="s0">None</span>, require_numeric=<span class="s0">True</span>):
    <span class="s2">&quot;&quot;&quot;Determine how the plot should be oriented based on the data. 
 
    For historical reasons, the convention is to call a plot &quot;horizontally&quot; 
    or &quot;vertically&quot; oriented based on the axis representing its dependent 
    variable. Practically, this is used when determining the axis for 
    numerical aggregation. 
 
    Paramters 
    --------- 
    x, y : Vector data or None 
        Positional data vectors for the plot. 
    orient : string or None 
        Specified orientation, which must start with &quot;v&quot; or &quot;h&quot; if not None. 
    require_numeric : bool 
        If set, raise when the implied dependent variable is not numeric. 
 
    Returns 
    ------- 
    orient : &quot;v&quot; or &quot;h&quot; 
 
    Raises 
    ------ 
    ValueError: When `orient` is not None and does not start with &quot;h&quot; or &quot;v&quot; 
    TypeError: When dependant variable is not numeric, with `require_numeric` 
 
    &quot;&quot;&quot;</span>

    x_type = <span class="s0">None if </span>x <span class="s0">is None else </span>variable_type(x)
    y_type = <span class="s0">None if </span>y <span class="s0">is None else </span>variable_type(y)

    nonnumeric_dv_error = <span class="s3">&quot;{} orientation requires numeric `{}` variable.&quot;</span>
    single_var_warning = <span class="s3">&quot;{} orientation ignored with only `{}` specified.&quot;</span>

    <span class="s0">if </span>x <span class="s0">is None</span>:
        <span class="s0">if </span>str(orient).startswith(<span class="s3">&quot;h&quot;</span>):
            warnings.warn(single_var_warning.format(<span class="s3">&quot;Horizontal&quot;</span>, <span class="s3">&quot;y&quot;</span>))
        <span class="s0">if </span>require_numeric <span class="s0">and </span>y_type != <span class="s3">&quot;numeric&quot;</span>:
            <span class="s0">raise </span>TypeError(nonnumeric_dv_error.format(<span class="s3">&quot;Vertical&quot;</span>, <span class="s3">&quot;y&quot;</span>))
        <span class="s0">return </span><span class="s3">&quot;v&quot;</span>

    <span class="s0">elif </span>y <span class="s0">is None</span>:
        <span class="s0">if </span>str(orient).startswith(<span class="s3">&quot;v&quot;</span>):
            warnings.warn(single_var_warning.format(<span class="s3">&quot;Vertical&quot;</span>, <span class="s3">&quot;x&quot;</span>))
        <span class="s0">if </span>require_numeric <span class="s0">and </span>x_type != <span class="s3">&quot;numeric&quot;</span>:
            <span class="s0">raise </span>TypeError(nonnumeric_dv_error.format(<span class="s3">&quot;Horizontal&quot;</span>, <span class="s3">&quot;x&quot;</span>))
        <span class="s0">return </span><span class="s3">&quot;h&quot;</span>

    <span class="s0">elif </span>str(orient).startswith(<span class="s3">&quot;v&quot;</span>):
        <span class="s0">if </span>require_numeric <span class="s0">and </span>y_type != <span class="s3">&quot;numeric&quot;</span>:
            <span class="s0">raise </span>TypeError(nonnumeric_dv_error.format(<span class="s3">&quot;Vertical&quot;</span>, <span class="s3">&quot;y&quot;</span>))
        <span class="s0">return </span><span class="s3">&quot;v&quot;</span>

    <span class="s0">elif </span>str(orient).startswith(<span class="s3">&quot;h&quot;</span>):
        <span class="s0">if </span>require_numeric <span class="s0">and </span>x_type != <span class="s3">&quot;numeric&quot;</span>:
            <span class="s0">raise </span>TypeError(nonnumeric_dv_error.format(<span class="s3">&quot;Horizontal&quot;</span>, <span class="s3">&quot;x&quot;</span>))
        <span class="s0">return </span><span class="s3">&quot;h&quot;</span>

    <span class="s0">elif </span>orient <span class="s0">is not None</span>:
        <span class="s0">raise </span>ValueError(<span class="s3">f&quot;Value for `orient` not understood: </span><span class="s0">{</span>orient<span class="s0">}</span><span class="s3">&quot;</span>)

    <span class="s0">elif </span>x_type != <span class="s3">&quot;numeric&quot; </span><span class="s0">and </span>y_type == <span class="s3">&quot;numeric&quot;</span>:
        <span class="s0">return </span><span class="s3">&quot;v&quot;</span>

    <span class="s0">elif </span>x_type == <span class="s3">&quot;numeric&quot; </span><span class="s0">and </span>y_type != <span class="s3">&quot;numeric&quot;</span>:
        <span class="s0">return </span><span class="s3">&quot;h&quot;</span>

    <span class="s0">elif </span>require_numeric <span class="s0">and </span><span class="s3">&quot;numeric&quot; </span><span class="s0">not in </span>(x_type, y_type):
        err = <span class="s3">&quot;Neither the `x` nor `y` variable appears to be numeric.&quot;</span>
        <span class="s0">raise </span>TypeError(err)

    <span class="s0">else</span>:
        <span class="s0">return </span><span class="s3">&quot;v&quot;</span>


<span class="s0">def </span>unique_dashes(n):
    <span class="s2">&quot;&quot;&quot;Build an arbitrarily long list of unique dash styles for lines. 
 
    Parameters 
    ---------- 
    n : int 
        Number of unique dash specs to generate. 
 
    Returns 
    ------- 
    dashes : list of strings or tuples 
        Valid arguments for the ``dashes`` parameter on 
        :class:`matplotlib.lines.Line2D`. The first spec is a solid 
        line (``&quot;&quot;``), the remainder are sequences of long and short 
        dashes. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Start with dash specs that are well distinguishable</span>
    dashes = [
        <span class="s3">&quot;&quot;</span>,
        (<span class="s4">4</span>, <span class="s4">1.5</span>),
        (<span class="s4">1</span>, <span class="s4">1</span>),
        (<span class="s4">3</span>, <span class="s4">1.25</span>, <span class="s4">1.5</span>, <span class="s4">1.25</span>),
        (<span class="s4">5</span>, <span class="s4">1</span>, <span class="s4">1</span>, <span class="s4">1</span>),
    ]

    <span class="s2"># Now programatically build as many as we need</span>
    p = <span class="s4">3</span>
    <span class="s0">while </span>len(dashes) &lt; n:

        <span class="s2"># Take combinations of long and short dashes</span>
        a = itertools.combinations_with_replacement([<span class="s4">3</span>, <span class="s4">1.25</span>], p)
        b = itertools.combinations_with_replacement([<span class="s4">4</span>, <span class="s4">1</span>], p)

        <span class="s2"># Interleave the combinations, reversing one of the streams</span>
        segment_list = itertools.chain(*zip(
            list(a)[<span class="s4">1</span>:-<span class="s4">1</span>][::-<span class="s4">1</span>],
            list(b)[<span class="s4">1</span>:-<span class="s4">1</span>]
        ))

        <span class="s2"># Now insert the gaps</span>
        <span class="s0">for </span>segments <span class="s0">in </span>segment_list:
            gap = min(segments)
            spec = tuple(itertools.chain(*((seg, gap) <span class="s0">for </span>seg <span class="s0">in </span>segments)))
            dashes.append(spec)

        p += <span class="s4">1</span>

    <span class="s0">return </span>dashes[:n]


<span class="s0">def </span>unique_markers(n):
    <span class="s2">&quot;&quot;&quot;Build an arbitrarily long list of unique marker styles for points. 
 
    Parameters 
    ---------- 
    n : int 
        Number of unique marker specs to generate. 
 
    Returns 
    ------- 
    markers : list of string or tuples 
        Values for defining :class:`matplotlib.markers.MarkerStyle` objects. 
        All markers will be filled. 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Start with marker specs that are well distinguishable</span>
    markers = [
        <span class="s3">&quot;o&quot;</span>,
        <span class="s3">&quot;X&quot;</span>,
        (<span class="s4">4</span>, <span class="s4">0</span>, <span class="s4">45</span>),
        <span class="s3">&quot;P&quot;</span>,
        (<span class="s4">4</span>, <span class="s4">0</span>, <span class="s4">0</span>),
        (<span class="s4">4</span>, <span class="s4">1</span>, <span class="s4">0</span>),
        <span class="s3">&quot;^&quot;</span>,
        (<span class="s4">4</span>, <span class="s4">1</span>, <span class="s4">45</span>),
        <span class="s3">&quot;v&quot;</span>,
    ]

    <span class="s2"># Now generate more from regular polygons of increasing order</span>
    s = <span class="s4">5</span>
    <span class="s0">while </span>len(markers) &lt; n:
        a = <span class="s4">360 </span>/ (s + <span class="s4">1</span>) / <span class="s4">2</span>
        markers.extend([
            (s + <span class="s4">1</span>, <span class="s4">1</span>, a),
            (s + <span class="s4">1</span>, <span class="s4">0</span>, a),
            (s, <span class="s4">1</span>, <span class="s4">0</span>),
            (s, <span class="s4">0</span>, <span class="s4">0</span>),
        ])
        s += <span class="s4">1</span>

    <span class="s2"># Convert to MarkerStyle object, using only exactly what we need</span>
    <span class="s2"># markers = [mpl.markers.MarkerStyle(m) for m in markers[:n]]</span>

    <span class="s0">return </span>markers[:n]


<span class="s0">def </span>categorical_order(vector, order=<span class="s0">None</span>):
    <span class="s2">&quot;&quot;&quot;Return a list of unique data values. 
 
    Determine an ordered list of levels in ``values``. 
 
    Parameters 
    ---------- 
    vector : list, array, Categorical, or Series 
        Vector of &quot;categorical&quot; values 
    order : list-like, optional 
        Desired order of category levels to override the order determined 
        from the ``values`` object. 
 
    Returns 
    ------- 
    order : list 
        Ordered list of category levels not including null values. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span>order <span class="s0">is None</span>:
        <span class="s0">if </span>hasattr(vector, <span class="s3">&quot;categories&quot;</span>):
            order = vector.categories
        <span class="s0">else</span>:
            <span class="s0">try</span>:
                order = vector.cat.categories
            <span class="s0">except </span>(TypeError, AttributeError):

                <span class="s0">try</span>:
                    order = vector.unique()
                <span class="s0">except </span>AttributeError:
                    order = pd.unique(vector)

                <span class="s0">if </span>variable_type(vector) == <span class="s3">&quot;numeric&quot;</span>:
                    order = np.sort(order)

        order = filter(pd.notnull, order)
    <span class="s0">return </span>list(order)
</pre>
</body>
</html>